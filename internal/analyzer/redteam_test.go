package analyzer_test

import (
	"fmt"
	"os"
	"strings"
	"testing"

	"gopkg.in/yaml.v3"
)

// ---------------------------------------------------------------------------
// Red-Team YAML types (mirrors guardian/redteam_test.go types)
// ---------------------------------------------------------------------------

type rtCommand struct {
	Cmd             string   `yaml:"cmd"`
	GuardianMin     string   `yaml:"guardian_min"`
	PipelineMin     string   `yaml:"pipeline_min"`
	ExpectedSignals []string `yaml:"expected_signals"`
}

type rtCase struct {
	ID           string      `yaml:"id"`
	AgentContext string      `yaml:"agent_context"`
	Commands     []rtCommand `yaml:"commands"`
	Description  string      `yaml:"description"`
}

type rtSuite struct {
	Cases []rtCase `yaml:"cases"`
}

func loadRedTeamYAML(t *testing.T) []rtCase {
	t.Helper()
	data, err := os.ReadFile("../guardian/testdata/redteam_cases.yaml")
	if err != nil {
		t.Fatalf("failed to read red-team YAML: %v", err)
	}
	var suite rtSuite
	if err := yaml.Unmarshal(data, &suite); err != nil {
		t.Fatalf("failed to parse red-team YAML: %v", err)
	}
	if len(suite.Cases) == 0 {
		t.Fatal("no red-team cases loaded")
	}
	return suite.Cases
}

func rtDecisionSev(d string) int {
	switch strings.ToUpper(d) {
	case "BLOCK":
		return 2
	case "AUDIT":
		return 1
	case "ALLOW":
		return 0
	default:
		return -1
	}
}

// TestRedTeamPipeline runs all red-team cases through the full 6-layer pipeline
// (regex + structural + semantic + dataflow + stateful + guardian) and asserts
// each command meets the pipeline_min decision from the YAML spec.
func TestRedTeamPipeline(t *testing.T) {
	cases := loadRedTeamYAML(t)
	engine := newPipelineEngine(t)

	var passed, failed int

	for _, tc := range cases {
		t.Run(tc.ID, func(t *testing.T) {
			for _, cmd := range tc.Commands {
				result := engine.Evaluate(cmd.Cmd, nil)

				gotSev := rtDecisionSev(string(result.Decision))
				wantSev := rtDecisionSev(cmd.PipelineMin)

				if gotSev < wantSev {
					t.Errorf("  command: %q\n    expected pipeline_min: %s (sev=%d)\n    got:                   %s (sev=%d)\n    triggered rules:       %v",
						cmd.Cmd, cmd.PipelineMin, wantSev,
						result.Decision, gotSev, result.TriggeredRules)
					failed++
				} else {
					passed++
				}
			}
		})
	}

	t.Logf("\n  Full-pipeline red-team: %d/%d command checks passed", passed, passed+failed)
}

// TestRedTeamPipelineReport generates a combined report with both
// guardian-only and full-pipeline results, written to REDTEAM_REPORT.md.
func TestRedTeamPipelineReport(t *testing.T) {
	cases := loadRedTeamYAML(t)
	engine := newPipelineEngine(t)

	var sb strings.Builder
	sb.WriteString("# AgentShield Red-Team Regression Report\n\n")
	sb.WriteString("> Auto-generated by `TestRedTeamPipelineReport`\n")
	sb.WriteString("> Run: `go test -v -run TestRedTeamPipelineReport ./internal/analyzer/`\n\n")

	sb.WriteString("## Full Pipeline Results (6-layer)\n\n")
	sb.WriteString("| Case | Command | Pipeline Min | Got | Triggered Rules | Status |\n")
	sb.WriteString("|------|---------|-------------|-----|-----------------|--------|\n")

	total, pass := 0, 0
	for _, tc := range cases {
		for _, cmd := range tc.Commands {
			total++
			result := engine.Evaluate(cmd.Cmd, nil)

			status := "PASS"
			if rtDecisionSev(string(result.Decision)) < rtDecisionSev(cmd.PipelineMin) {
				status = "FAIL"
			} else {
				pass++
			}

			shortCmd := cmd.Cmd
			if len(shortCmd) > 55 {
				shortCmd = shortCmd[:52] + "..."
			}

			rules := strings.Join(result.TriggeredRules, ", ")
			if rules == "" {
				rules = "(default)"
			}
			sb.WriteString(fmt.Sprintf("| `%s` | `%s` | %s | %s | %s | %s |\n",
				tc.ID, shortCmd, cmd.PipelineMin, result.Decision, rules, status))
		}
	}

	sb.WriteString(fmt.Sprintf("\n**Full pipeline: %d/%d commands meet minimum decision (%0.1f%%)**\n\n",
		pass, total, float64(pass)/float64(total)*100))

	sb.WriteString("## Legend\n\n")
	sb.WriteString("- **Pipeline Min**: The minimum acceptable decision for this command\n")
	sb.WriteString("- **Got**: The actual decision from the 6-layer pipeline\n")
	sb.WriteString("- Pipeline layers: regex → structural → semantic → dataflow → stateful → guardian\n")

	reportPath := "../../REDTEAM_REPORT.md"
	if err := os.WriteFile(reportPath, []byte(sb.String()), 0644); err != nil {
		t.Fatalf("failed to write report: %v", err)
	}
	t.Logf("Generated %s with %d command checks", reportPath, total)
}
